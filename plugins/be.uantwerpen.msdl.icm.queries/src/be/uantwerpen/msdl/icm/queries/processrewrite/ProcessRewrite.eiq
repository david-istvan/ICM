package be.uantwerpen.msdl.icm.queries.processrewrite

import "metamodels.process"
import pattern be.uantwerpen.msdl.icm.queries.validation.nodeGloballyReachableFromNode

/**
 * Activities are connected via a control flow
 */
pattern controlFlowBetweenNodes(node1: Node, node2: Node, controlFlow: ControlFlow){
	ControlFlow.fromNode(controlFlow, node1);
	ControlFlow.toNode(controlFlow, node2);
}

/**
 * Hard control flow constraint
 */
pattern hardControlFlowBetweenActivities(activity1: Activity, activity2: Activity, controlFlow: ControlFlow){
	find controlFlowBetweenNodes(activity1, activity2, controlFlow);
	ControlFlow.final(controlFlow, f);
	f == true;
}

/**
 * Soft control flow constraint
 */
pattern softControlFlowBetweenActivities(activity1: Activity, activity2: Activity, controlFlow: ControlFlow, process: Process){
	find controlFlowBetweenNodes(activity1, activity2, controlFlow);
	ControlFlow.final(controlFlow, f);
	Process.controlFlow(process, controlFlow);
	f != true;
}

/**
 * Activities w/o control flow constraint
 */
pattern independentActivities(process: Process, activity1: Activity, activity2: Activity){
	find independentNodes(process, activity1, activity2);
}
 
 
pattern independentNodes(process: Process, node1: Node, node2: Node){
	Process.node(process, node1);
	Process.node(process, node2);
	node1!=node2;
	neg find controlFlowBetweenNodes(node1, node2, _);
}

pattern independentNodes2(process: Process, node1: Node, node2: Node){
	find independentNodes(process, node1, node2);
}

pattern controlFlow(process: Process, controlFlow: ControlFlow){
	Process.controlFlow(process, controlFlow);
}

/**
 * Object flow
 */
pattern objectFlowBetweenIndependentActivities(activity1: Activity, activity2: Activity){
	find controlFlowBetweenNodes(activity1, activity2, _);
	
	Object.dataFlowFrom(object, activity1);
	Object.dataFlowTo(object, activity2);
}

pattern intent(activity: Activity, property: Property, intent: Intent){
	Intent.activity(intent, activity);
	Intent.subjectOfIntent(intent, property);
}

/**
 * Two activities touch the same property and they have a shared object.
 * TODO this is not enough: types of intents lead back to temporal tolerance!!!
 */
pattern sharedProperty(activity1: Activity, activity2: Activity, property: Property){
	find intent(activity1, property, _);
	find intent(activity2, property, _);
	
}

pattern readModifySharedProperty(activity1: Activity, activity2: Activity, property: Property){
	find readIntentOnActivity(activity1, property);
	find modifyIntentOnActivity(activity2, property);
	find nodeGloballyReachableFromNode(activity1, activity2);
}

pattern readModifySharedProperty2(activity1: Activity, activity2: Activity, property: Property, process: Process){
	find readModifySharedProperty(activity1, activity2, property);
	Process.node(process, activity1);
}

pattern readIntentOnActivity(activity: Activity, property: Property){
	find intent(activity, property, intent);
	Intent.type(intent, IntentType::READ);
}

pattern modifyIntentOnActivity(activity: Activity, property: Property){
	find intent(activity, property, intent);
	Intent.type(intent, IntentType::MODIFY);
}

pattern checkIntentOnActivity(activity: Activity, property: Property){
	find intent(activity, property, intent);
	Intent.type(intent, IntentType::CHECK);
}

pattern lockIntentOnActivity(activity: Activity, property: Property){
	find intent(activity, property, intent);
	Intent.type(intent, IntentType::LOCK);
}

pattern releaseIntentOnActivity(activity: Activity, property: Property){
	find intent(activity, property, intent);
	Intent.type(intent, IntentType::RELEASE);
}

pattern forkOutControl(forkNode : Fork){
	Fork.controlOut(forkNode,_);
}